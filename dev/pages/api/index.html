<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · StaticArrays.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>StaticArrays.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li class="current"><a class="toctext" href>API</a><ul class="internal"><li><a class="toctext" href="#Guide-1">Guide</a></li><li><a class="toctext" href="#Docstrings-1">Docstrings</a></li></ul></li><li><a class="toctext" href="../quickstart/">Quick Start</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>API</a></li></ul><a class="edit-page" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/master/docs/src/pages/api.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>API</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="API-1" href="#API-1">API</a></h1><h2><a class="nav-anchor" id="Guide-1" href="#Guide-1">Guide</a></h2><h3><a class="nav-anchor" id="SVector-1" href="#SVector-1"><code>SVector</code></a></h3><p>The simplest static array is the type <code>SVector{N,T}</code>, which provides an immutable vector of fixed length <code>N</code> and type <code>T</code>.</p><p><code>SVector</code> defines a series of convenience constructors, so you can just type e.g. <code>SVector(1,2,3)</code>. Alternatively there is an intelligent <code>@SVector</code> macro where you can use native Julia array literals syntax, comprehensions, and the <code>zeros()</code>, <code>ones()</code>, <code>fill()</code>, <code>rand()</code> and <code>randn()</code> functions, such as <code>@SVector [1,2,3]</code>, <code>@SVector Float64[1,2,3]</code>, <code>@SVector [f(i) for i = 1:10]</code>, <code>@SVector zeros(3)</code>, <code>@SVector randn(Float32, 4)</code>, etc (Note: the range of a comprehension is evaluated at global scope by the macro, and must be made of combinations of literal values, functions, or global variables, but is not limited to just simple ranges. Extending this to (hopefully statically known by type-inference) local-scope variables is hoped for the future. The <code>zeros()</code>, <code>ones()</code>, <code>fill()</code>, <code>rand()</code> and <code>randn()</code> functions do not have this limitation.)</p><h3><a class="nav-anchor" id="SMatrix-1" href="#SMatrix-1"><code>SMatrix</code></a></h3><p>Statically sized <code>N×M</code> matrices are provided by <code>SMatrix{N,M,T,L}</code>.</p><p>Here <code>L</code> is the <code>length</code> of the matrix, such that <code>N × M = L</code>. However, convenience constructors are provided, so that <code>L</code>, <code>T</code> and even <code>M</code> are unnecessary. At minimum, you can type <code>SMatrix{2}(1,2,3,4)</code> to create a 2×2 matrix (the total number of elements must divide evenly into <code>N</code>). A convenience macro <code>@SMatrix [1 2; 3 4]</code> is provided (which also accepts comprehensions and the <code>zeros()</code>, <code>ones()</code>, <code>fill()</code>, <code>rand()</code>, <code>randn()</code> and <code>eye()</code> functions).</p><h3><a class="nav-anchor" id="SArray-1" href="#SArray-1"><code>SArray</code></a></h3><p>A container with arbitrarily many dimensions is defined as <code>struct SArray{Size,T,N,L} &lt;: StaticArray{Size,T,N}</code>, where <code>Size = Tuple{S1, S2, ...}</code> is a tuple of <code>Int</code>s. You can easily construct one with the <code>@SArray</code> macro, supporting all the features of <code>@SVector</code> and <code>@SMatrix</code> (but with arbitrary dimension).</p><p>The main reason <code>SVector</code> and <code>SMatrix</code> are defined is to make it easier to define the types without the extra tuple characters (compare <code>SVector{3}</code> to <code>SArray{Tuple{3}}</code>).</p><h3><a class="nav-anchor" id="Scalar-1" href="#Scalar-1"><code>Scalar</code></a></h3><p>Sometimes you want to broadcast an operation, but not over one of your inputs. A classic example is attempting to displace a collection of vectors by the same vector. We can now do this with the <code>Scalar</code> type:</p><pre><code class="language-julia">[[1,2,3], [4,5,6]] .+ Scalar([1,0,-1]) # [[2,2,2], [5,5,5]]</code></pre><p><code>Scalar</code> is simply an implementation of an immutable, 0-dimensional <code>StaticArray</code>.</p><h3><a class="nav-anchor" id="The-Size-trait-1" href="#The-Size-trait-1">The <code>Size</code> trait</a></h3><p>The size of a statically sized array is a static parameter associated with the type of the array. The <code>Size</code> trait is provided as an abstract representation of the dimensions of a static array. An array <code>sa::SA</code> of size <code>(dims...)</code> is associated with <code>Size{(dims...)}()</code>. The following are equivalent (<code>@pure</code>) constructors:</p><pre><code class="language-julia">Size{(dims...,)}()
Size(dims...)
Size(sa::StaticArray)
Size(SA) # SA &lt;: StaticArray</code></pre><p>This is extremely useful for (a) performing dispatch depending on the size of an array, and (b) passing array dimensions that the compiler can reason about.</p><p>An example of size-based dispatch for the determinant of a matrix would be:</p><pre><code class="language-julia">det(x::StaticMatrix) = _det(Size(x), x)
_det(::Size{(1,1)}, x::StaticMatrix) = x[1,1]
_det(::Size{(2,2)}, x::StaticMatrix) = x[1,1]*x[2,2] - x[1,2]*x[2,1]
# and other definitions as necessary</code></pre><p>Examples of using <code>Size</code> as a compile-time constant include</p><pre><code class="language-julia">reshape(svector, Size(2,2))  # Convert SVector{4} to SMatrix{2,2}
SizedMatrix{3,3}(rand(3,3))  # Construct a random 3×3 SizedArray (see below)</code></pre><h3><a class="nav-anchor" id="Indexing-1" href="#Indexing-1">Indexing</a></h3><p>Statically sized indexing can be realized by indexing each dimension by a scalar, a <code>StaticVector</code> or <code>:</code>. Indexing in this way will result a statically sized array (even if the input was dynamically sized, in the case of <code>StaticVector</code> indices) of the closest type (as defined by <code>similar_type</code>).</p><p>Conversely, indexing a statically sized array with a dynamically sized index (such as a <code>Vector{Integer}</code> or <code>UnitRange{Integer}</code>) will result in a standard (dynamically sized) <code>Array</code>.</p><h3><a class="nav-anchor" id="similar_type()-1" href="#similar_type()-1"><code>similar_type()</code></a></h3><p>Since immutable arrays need to be constructed &quot;all-at-once&quot;, we need a way of obtaining an appropriate constructor if the element type or dimensions of the output array differs from the input. To this end, <code>similar_type</code> is introduced, behaving just like <code>similar</code>, except that it returns a type. Relevant methods are:</p><pre><code class="language-julia">similar_type(::Type{A}) where {A &lt;: StaticArray} # defaults to A
similar_type(::Type{A}, ::Type{ElType}) where {A &lt;: StaticArray, ElType} # Change element type
similar_type(::Type{A}, size::Size) where {A &lt;: AbstractArray} # Change size
similar_type(::Type{A}, ::Type{ElType}, size::Size) where {A &lt;: AbstractArray, ElType} # Change both</code></pre><p>These setting will affect everything, from indexing, to matrix multiplication and <code>broadcast</code>. Users wanting introduce a new array type should <em>only</em> overload the last method in the above.</p><p>Use of <code>similar</code> will fall back to a mutable container, such as a <code>MVector</code> (see below), and it requires use of the <code>Size</code> trait if you wish to set a new static size (or else a dynamically sized <code>Array</code> will be generated when specifying the size as plain integers).</p><h3><a class="nav-anchor" id="Mutable-arrays:-MVector,-MMatrix-and-MArray-1" href="#Mutable-arrays:-MVector,-MMatrix-and-MArray-1">Mutable arrays: <code>MVector</code>, <code>MMatrix</code> and <code>MArray</code></a></h3><p>These statically sized arrays are identical to the above, but are defined as <code>mutable struct</code>s, instead of immutable <code>struct</code>s. Because they are mutable, they allow <code>setindex!</code> to be defined (achieved through pointer manipulation, into a tuple).</p><p>As a consequence of Julia&#39;s internal implementation, these mutable containers live on the heap, not the stack. Their memory must be allocated and tracked by the garbage collector. Nevertheless, there is opportunity for speed improvements relative to <code>Base.Array</code> because (a) there may be one less pointer indirection, (b) their (typically small) static size allows for additional loop unrolling and inlining, and consequentially (c) their mutating methods like <code>map!</code> are extremely fast. Benchmarking shows that operations such as addition and matrix multiplication are faster for <code>MMatrix</code> than <code>Matrix</code>, at least for sizes up to 14 × 14, though keep in mind that optimal speed will be obtained by using mutating functions (like <code>map!</code> or <code>A_mul_B!</code>) where possible, rather than reallocating new memory.</p><p>Mutable static arrays also happen to be very useful containers that can be constructed on the heap (with the ability to use <code>setindex!</code>, etc), and later copied as e.g. an immutable <code>SVector</code> to the stack for use, or into e.g. an <code>Array{SVector}</code> for storage.</p><p>Convenience macros <code>@MVector</code>, <code>@MMatrix</code> and <code>@MArray</code> are provided.</p><h3><a class="nav-anchor" id="SizedArray:-a-decorate-size-wrapper-for-Array-1" href="#SizedArray:-a-decorate-size-wrapper-for-Array-1"><code>SizedArray</code>: a decorate size wrapper for <code>Array</code></a></h3><p>Another convenient mutable type is the <code>SizedArray</code>, which is just a wrapper-type about a standard Julia <code>Array</code> which declares its known size. For example, if we knew that <code>a</code> was a 2×2 <code>Matrix</code>, then we can type <code>sa = SizedArray{Tuple{2,2}}(a)</code> to construct a new object which knows the type (the size will be verified automatically). For one and two dimensions, a more convenient syntax for obtaining a <code>SizedArray</code> is by using the <code>SizedMatrix</code> and <code>SizedVector</code> aliases, e.g. <code>sa = SizedMatrix{2,2}(a)</code>.</p><p>Then, methods on <code>sa</code> will use the specialized code provided by the <em>StaticArrays</em> package, which in many cases will be much, much faster. For example, calling <code>eigen(sa)</code> will be signficantly faster than <code>eigen(a)</code> since it will perform a specialized 2×2 matrix diagonalization rather than a general algorithm provided by Julia and <em>LAPACK</em>.</p><p>In some cases it will make more sense to use a <code>SizedArray</code>, and in other cases an <code>MArray</code> might be preferable.</p><h3><a class="nav-anchor" id="FieldVector-1" href="#FieldVector-1"><code>FieldVector</code></a></h3><p>Sometimes it is useful to give your own struct types the properties of a vector. <em>StaticArrays</em> can take care of this for you by allowing you to inherit from <code>FieldVector{N, T}</code>. For example, consider:</p><pre><code class="language-julia">struct Point3D &lt;: FieldVector{3, Float64}
    x::Float64
    y::Float64
    z::Float64
end</code></pre><p>With this type, users can easily access fields to <code>p = Point3D(x,y,z)</code> using <code>p.x</code>, <code>p.y</code> or <code>p.z</code>, or alternatively via <code>p[1]</code>, <code>p[2]</code>, or <code>p[3]</code>. You may even permute the coordinates with <code>p[SVector(3,2,1)]</code>). Furthermore, <code>Point3D</code> is a complete <code>AbstractVector</code> implementation where you can add, subtract or scale vectors, multiply them by matrices, etc.</p><p>It is also worth noting that <code>FieldVector</code>s may be mutable or immutable, and that <code>setindex!</code> is defined for use on mutable types. For immutable containers, you may want to define a method for <code>similar_type</code> so that operations leave the type constant (otherwise they may fall back to <code>SVector</code>). For mutable containers, you may want to define a default constructor (no inputs) and an appropriate method for <code>similar</code>,</p><h3><a class="nav-anchor" id="Implementing-your-own-types-1" href="#Implementing-your-own-types-1">Implementing your own types</a></h3><p>You can easily create your own <code>StaticArray</code> type, by defining linear <code>getindex</code> (and optionally <code>setindex!</code> for mutable types –- see <code>setindex(::MArray, val, i)</code> in <em>MArray.jl</em> for an example of how to achieve this through pointer manipulation). Your type should define a constructor that takes a tuple of the data (and mutable containers may want to define a default constructor).</p><p>Other useful functions to overload may be <code>similar_type</code> (and <code>similar</code> for mutable containers).</p><h3><a class="nav-anchor" id="Conversions-from-Array-1" href="#Conversions-from-Array-1">Conversions from <code>Array</code></a></h3><p>In order to convert from a dynamically sized <code>AbstractArray</code> to one of the statically sized array types, you must specify the size explicitly.  For example,</p><pre><code class="language-julia">v = [1,2]

m = [1 2;
     3 4]

# ... a lot of intervening code

sv = SVector{2}(v)
sm = SMatrix{2,2}(m)
sa = SArray{Tuple{2,2}}(m)

sized_v = SizedVector{2}(v)
sized_m = SizedMatrix{2,2}(m)</code></pre><p>We have avoided adding <code>SVector(v::AbstractVector)</code> as a valid constructor to help users avoid the type instability (and potential performance disaster, if used without care) of this innocuous looking expression.</p><h3><a class="nav-anchor" id="Arrays-of-static-arrays-1" href="#Arrays-of-static-arrays-1">Arrays of static arrays</a></h3><p>Storing a large number of static arrays is convenient as an array of static arrays. For example, a collection of positions (3D coordinates –- <code>SVector{3,Float64}</code>) could be represented as a <code>Vector{SVector{3,Float64}}</code>.</p><p>Another common way of storing the same data is as a 3×<code>N</code> <code>Matrix{Float64}</code>. Rather conveniently, such types have <em>exactly</em> the same binary layout in memory, and therefore we can use <code>reinterpret</code> to convert between the two formats</p><pre><code class="language-julia">function svectors(x::Matrix{T}, ::Val{N}) where {T,N}
    size(x,1) == N || error(&quot;sizes mismatch&quot;)
    isbitstype(T) || error(&quot;use for bitstypes only&quot;)
    reinterpret(SVector{N,T}, vec(x))
end</code></pre><p>Such a conversion does not copy the data, rather it refers to the <em>same</em> memory. Arguably, a <code>Vector</code> of <code>SVector</code>s is often preferable to a <code>Matrix</code> because it provides a better abstraction of the objects contained in the array and it allows the fast <em>StaticArrays</em> methods to act on elements.</p><p>However, the resulting object is a Base.ReinterpretArray, not an Array, which carries some runtime penalty on every single access. If you can afford the memory for a copy and can live with the non-shared mutation semantics, then it is better to pull a copy by e.g.</p><pre><code class="language-julia">function svectorscopy(x::Matrix{T}, ::Val{N}) where {T,N}
    size(x,1) == N || error(&quot;sizes mismatch&quot;)
    isbitstype(T) || error(&quot;use for bitstypes only&quot;)
    copy(reinterpret(SVector{N,T}, vec(x)))
end</code></pre><p>For example:</p><pre><code class="language-none">julia&gt; M=reshape(collect(1:6), (2,3))
2×3 Array{Int64,2}:
 1  3  5
 2  4  6

julia&gt; svectors(M, Val{2}())
3-element reinterpret(SArray{Tuple{2},Int64,1,2}, ::Array{Int64,1}):
 [1, 2]
 [3, 4]
 [5, 6]

julia&gt; svectorscopy(M, Val{2}())
3-element Array{SArray{Tuple{2},Int64,1,2},1}:
 [1, 2]
 [3, 4]
 [5, 6]</code></pre><h3><a class="nav-anchor" id="Working-with-mutable-and-immutable-arrays-1" href="#Working-with-mutable-and-immutable-arrays-1">Working with mutable and immutable arrays</a></h3><p>Generally, it is performant to rebind an <em>immutable</em> array, such as</p><pre><code class="language-julia">function average_position(positions::Vector{SVector{3,Float64}})
    x = zeros(SVector{3,Float64})
    for pos ∈ positions
        x = x + pos
    end
    return x / length(positions)
end</code></pre><p>so long as the <code>Type</code> of the rebound variable (<code>x</code>, above) does not change.</p><p>On the other hand, the above code for mutable containers like <code>Array</code>, <code>MArray</code> or <code>SizedArray</code> is <em>not</em> very efficient. Mutable containers in Julia 0.5 must be <em>allocated</em> and later <em>garbage collected</em>, and for small, fixed-size arrays this can be a leading contribution to the cost. In the above code, a new array will be instantiated and allocated on each iteration of the loop. In order to avoid unnecessary allocations, it is best to allocate an array only once and apply mutating functions to it:</p><pre><code class="language-julia">function average_position(positions::Vector{SVector{3,Float64}})
    x = zeros(MVector{3,Float64})
    for pos ∈ positions
        # Take advantage of Julia 0.5 broadcast fusion
        x .= (+).(x, pos) # same as broadcast!(+, x, x, positions[i])
    end
    x .= (/).(x, length(positions))
    return x
end</code></pre><p>Keep in mind that Julia 0.5 does not fuse calls to <code>.+</code>, etc (or <code>.+=</code> etc), however the <code>.=</code> and <code>(+).()</code> syntaxes are fused into a single, efficient call to <code>broadcast!</code>. The simpler syntax <code>x .+= pos</code> is expected to be non-allocating (and therefore faster) in Julia 0.6.</p><p>The functions <code>setindex</code>, <code>push</code>, <code>pop</code>, <code>pushfirst</code>, <code>popfirst</code>, <code>insert</code> and <code>deleteat</code> are provided for performing certain specific operations on static arrays, in analogy with the standard functions <code>setindex!</code>, <code>push!</code>, <code>pop!</code>, etc. (Note that if the size of the static array changes, the type of the output will differ from the input.)</p><p>When building static arrays iteratively, it is usually efficient to build up an <code>MArray</code> first and then convert. The allocation will be elided by recent Julia compilers, resulting in very efficient code:</p><pre><code class="language-julia">function standard_basis_vector(T, ::Val{I}, ::Val{N}) where {I,N}
    v = zero(MVector{N,T})
    v[I] = one(T)
    SVector(v)
end</code></pre><h3><a class="nav-anchor" id="SIMD-optimizations-1" href="#SIMD-optimizations-1">SIMD optimizations</a></h3><p>It seems Julia and LLVM are smart enough to use processor vectorization extensions like SSE and AVX - however they are currently partially disabled by default. Run Julia with <code>julia -O</code> or <code>julia -O3</code> to enable these optimizations, and many of your (immutable) <code>StaticArray</code> methods <em>should</em> become significantly faster!</p><h2><a class="nav-anchor" id="Docstrings-1" href="#Docstrings-1">Docstrings</a></h2><ul><li><a href="#StaticArrays.Dynamic"><code>StaticArrays.Dynamic</code></a></li><li><a href="#StaticArrays.FieldArray"><code>StaticArrays.FieldArray</code></a></li><li><a href="#StaticArrays.FieldMatrix"><code>StaticArrays.FieldMatrix</code></a></li><li><a href="#StaticArrays.FieldVector"><code>StaticArrays.FieldVector</code></a></li><li><a href="#StaticArrays.MArray"><code>StaticArrays.MArray</code></a></li><li><a href="#StaticArrays.MMatrix"><code>StaticArrays.MMatrix</code></a></li><li><a href="#StaticArrays.MVector"><code>StaticArrays.MVector</code></a></li><li><a href="#StaticArrays.SA"><code>StaticArrays.SA</code></a></li><li><a href="#StaticArrays.SArray"><code>StaticArrays.SArray</code></a></li><li><a href="#StaticArrays.SHermitianCompact"><code>StaticArrays.SHermitianCompact</code></a></li><li><a href="#StaticArrays.SMatrix"><code>StaticArrays.SMatrix</code></a></li><li><a href="#StaticArrays.SOneTo"><code>StaticArrays.SOneTo</code></a></li><li><a href="#StaticArrays.SVector"><code>StaticArrays.SVector</code></a></li><li><a href="#StaticArrays.Scalar"><code>StaticArrays.Scalar</code></a></li><li><a href="#StaticArrays.Size"><code>StaticArrays.Size</code></a></li><li><a href="#StaticArrays.SizedArray"><code>StaticArrays.SizedArray</code></a></li><li><a href="#StaticArrays.StaticArray"><code>StaticArrays.StaticArray</code></a></li><li><a href="#Base.setindex-Tuple{StaticArray,Any,Int64}"><code>Base.setindex</code></a></li><li><a href="#Base.similar-Union{Tuple{SA}, Tuple{SA}} where SA&lt;:StaticArray"><code>Base.similar</code></a></li><li><a href="#LinearAlgebra.qr"><code>LinearAlgebra.qr</code></a></li><li><a href="#StaticArrays._construct_similar-Union{Tuple{ET}, Tuple{L}, Tuple{Any,Size,Tuple{Vararg{ET,L}}}} where ET where L"><code>StaticArrays._construct_similar</code></a></li><li><a href="#StaticArrays._size-Tuple{Any}"><code>StaticArrays._size</code></a></li><li><a href="#StaticArrays.arithmetic_closure-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>StaticArrays.arithmetic_closure</code></a></li><li><a href="#StaticArrays.deleteat-Tuple{StaticArray{Tuple{N},T,1} where T where N,Any}"><code>StaticArrays.deleteat</code></a></li><li><a href="#StaticArrays.dimmatch"><code>StaticArrays.dimmatch</code></a></li><li><a href="#StaticArrays.insert-Tuple{StaticArray{Tuple{N},T,1} where T where N,Any,Any}"><code>StaticArrays.insert</code></a></li><li><a href="#StaticArrays.pop-Tuple{StaticArray{Tuple{N},T,1} where T where N}"><code>StaticArrays.pop</code></a></li><li><a href="#StaticArrays.popfirst-Tuple{StaticArray{Tuple{N},T,1} where T where N}"><code>StaticArrays.popfirst</code></a></li><li><a href="#StaticArrays.push-Tuple{StaticArray{Tuple{N},T,1} where T where N,Any}"><code>StaticArrays.push</code></a></li><li><a href="#StaticArrays.pushfirst-Tuple{StaticArray{Tuple{N},T,1} where T where N,Any}"><code>StaticArrays.pushfirst</code></a></li><li><a href="#StaticArrays.same_size-Tuple"><code>StaticArrays.same_size</code></a></li><li><a href="#StaticArrays.similar_type"><code>StaticArrays.similar_type</code></a></li><li><a href="#StaticArrays.size_to_tuple-Union{Tuple{Type{S}}, Tuple{S}} where S&lt;:Tuple"><code>StaticArrays.size_to_tuple</code></a></li><li><a href="#StaticArrays.sizematch-Union{Tuple{S}, Tuple{Size{S},StaticArray}} where S"><code>StaticArrays.sizematch</code></a></li><li><a href="#StaticArrays.sizematch-Union{Tuple{S2}, Tuple{S1}, Tuple{Size{S1},Size{S2}}} where S2 where S1"><code>StaticArrays.sizematch</code></a></li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.FieldArray" href="#StaticArrays.FieldArray"><code>StaticArrays.FieldArray</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">abstract FieldArray{N, T, D} &lt;: StaticArray{N, T, D}</code></pre><p>Inheriting from this type will make it easy to create your own rank-D tensor types. A <code>FieldArray</code> will automatically define <code>getindex</code> and <code>setindex!</code> appropriately. An immutable <code>FieldArray</code> will be as performant as an <code>SArray</code> of similar length and element type, while a mutable <code>FieldArray</code> will behave similarly to an <code>MArray</code>.</p><p>For example:</p><pre><code class="language-none">struct Stiffness &lt;: FieldArray{Tuple{2,2,2,2}, Float64, 4}
    xxxx::Float64
    yxxx::Float64
    xyxx::Float64
    yyxx::Float64
    xxyx::Float64
    yxyx::Float64
    xyyx::Float64
    yyyx::Float64
    xxxy::Float64
    yxxy::Float64
    xyxy::Float64
    yyxy::Float64
    xxyy::Float64
    yxyy::Float64
    xyyy::Float64
    yyyy::Float64
end</code></pre><p>Note that you must define the fields of any <code>FieldArray</code> subtype in column major order. If you  want to use an alternative ordering you will need to pay special attention in providing your  own definitions of <code>getindex</code>, <code>setindex!</code> and tuple conversion.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/103e9d4dabfdb64ccb378c8539d15136dde964de/src/FieldArray.jl#L1-L33">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.FieldMatrix" href="#StaticArrays.FieldMatrix"><code>StaticArrays.FieldMatrix</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">abstract FieldMatrix{N1, N2, T} &lt;: FieldArray{Tuple{N1, N2}, 2}</code></pre><p>Inheriting from this type will make it easy to create your own rank-two tensor types. A <code>FieldMatrix</code> will automatically define <code>getindex</code> and <code>setindex!</code> appropriately. An immutable <code>FieldMatrix</code> will be as performant as an <code>SMatrix</code> of similar length and element type, while a mutable <code>FieldMatrix</code> will behave similarly to an <code>MMatrix</code>.</p><p>For example:</p><pre><code class="language-none">struct Stress &lt;: FieldMatrix{3, 3, Float64}
    xx::Float64
    yx::Float64
    zx::Float64
    xy::Float64
    yy::Float64
    zy::Float64
    xz::Float64
    yz::Float64
    zz::Float64
end</code></pre><p>Note that the fields of any subtype of <code>FieldMatrix</code> must be defined in column major order.  This means that formatting of constructors for literal <code>FieldMatrix</code> can be confusing. For example</p><pre><code class="language-none">sigma = Stress(1.0, 2.0, 3.0,
               4.0, 5.0, 6.0,
               7.0, 8.0, 9.0)

3×3 Stress:
 1.0  4.0  7.0
 2.0  5.0  8.0
 3.0  6.0  9.0</code></pre><p>will give you the transpose of what the multi-argument formatting suggests. For clarity, you may consider using the alternative</p><pre><code class="language-none">sigma = Stress(@SArray[1.0 2.0 3.0;
                       4.0 5.0 6.0;
                       7.0 8.0 9.0])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/103e9d4dabfdb64ccb378c8539d15136dde964de/src/FieldArray.jl#L36-L77">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.FieldVector" href="#StaticArrays.FieldVector"><code>StaticArrays.FieldVector</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">abstract FieldVector{N, T} &lt;: FieldArray{Tuple{N}, 1}</code></pre><p>Inheriting from this type will make it easy to create your own vector types. A <code>FieldVector</code> will automatically define <code>getindex</code> and <code>setindex!</code> appropriately. An immutable <code>FieldVector</code> will be as performant as an <code>SVector</code> of similar length and element type, while a mutable <code>FieldVector</code> will behave similarly to an <code>MVector</code>.</p><p>For example:</p><pre><code class="language-none">struct Point3D &lt;: FieldVector{3, Float64}
    x::Float64
    y::Float64
    z::Float64
end</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/103e9d4dabfdb64ccb378c8539d15136dde964de/src/FieldArray.jl#L80-L95">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.MArray" href="#StaticArrays.MArray"><code>StaticArrays.MArray</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MArray{S, T, L}()
MArray{S, T, L}(x::NTuple{L, T})
MArray{S, T, L}(x1, x2, x3, ...)</code></pre><p>Construct a statically-sized, mutable array <code>MArray</code>. The data may optionally be provided upon construction and can be mutated later. The <code>S</code> parameter is a Tuple-type specifying the dimensions, or size, of the array - such as <code>Tuple{3,4,5}</code> for a 3×4×5-sized array. The <code>L</code> parameter is the <code>length</code> of the array and is always equal to <code>prod(S)</code>. Constructors may drop the <code>L</code> and <code>T</code> parameters if they are inferrable from the input (e.g. <code>L</code> is always inferrable from <code>S</code>).</p><pre><code class="language-none">MArray{S}(a::Array)</code></pre><p>Construct a statically-sized, mutable array of dimensions <code>S</code> (expressed as a <code>Tuple{...}</code>) using the data from <code>a</code>. The <code>S</code> parameter is mandatory since the size of <code>a</code> is unknown to the compiler (the element type may optionally also be specified).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/103e9d4dabfdb64ccb378c8539d15136dde964de/src/MArray.jl#L1-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.MMatrix" href="#StaticArrays.MMatrix"><code>StaticArrays.MMatrix</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MMatrix{S1, S2, T, L}()
MMatrix{S1, S2, T, L}(x::NTuple{L, T})
MMatrix{S1, S2, T, L}(x1, x2, x3, ...)</code></pre><p>Construct a statically-sized, mutable matrix <code>MMatrix</code>. The data may optionally be provided upon construction and can be mutated later. The <code>L</code> parameter is the <code>length</code> of the array and is always equal to <code>S1 * S2</code>. Constructors may drop the <code>L</code>, <code>T</code> and even <code>S2</code> parameters if they are inferrable from the input (e.g. <code>L</code> is always inferrable from <code>S1</code> and <code>S2</code>).</p><pre><code class="language-none">MMatrix{S1, S2}(mat::Matrix)</code></pre><p>Construct a statically-sized, mutable matrix of dimensions <code>S1 × S2</code> using the data from <code>mat</code>. The parameters <code>S1</code> and <code>S2</code> are mandatory since the size of <code>mat</code> is unknown to the compiler (the element type may optionally also be specified).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/103e9d4dabfdb64ccb378c8539d15136dde964de/src/MMatrix.jl#L1-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.MVector" href="#StaticArrays.MVector"><code>StaticArrays.MVector</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MVector{S,T}()
MVector{S,T}(x::NTuple{S, T})
MVector{S,T}(x1, x2, x3, ...)</code></pre><p>Construct a statically-sized, mutable vector <code>MVector</code>. Data may optionally be provided upon construction, and can be mutated later. Constructors may drop the <code>T</code> and <code>S</code> parameters if they are inferrable from the input (e.g. <code>MVector(1,2,3)</code> constructs an <code>MVector{3, Int}</code>).</p><pre><code class="language-none">MVector{S}(vec::Vector)</code></pre><p>Construct a statically-sized, mutable vector of length <code>S</code> using the data from <code>vec</code>. The parameter <code>S</code> is mandatory since the length of <code>vec</code> is unknown to the compiler (the element type may optionally also be specified).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/103e9d4dabfdb64ccb378c8539d15136dde964de/src/MVector.jl#L1-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.SA" href="#StaticArrays.SA"><code>StaticArrays.SA</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SA[ elements ]
SA{T}[ elements ]</code></pre><p>Create <code>SArray</code> literals using array construction syntax. The element type is inferred by promoting <code>elements</code> to a common type or set to <code>T</code> when <code>T</code> is provided explicitly.</p><p><strong>Examples:</strong></p><ul><li><code>SA[1.0, 2.0]</code> creates a length-2 <code>SVector</code> of <code>Float64</code> elements.</li><li><code>SA[1 2; 3 4]</code> creates a 2×2 SMatrix of <code>Int</code>s.</li><li><code>SA[1 2]</code> creates a 1×2 SMatrix of <code>Int</code>s.</li><li><code>SA{Float32}[1, 2]</code> creates a length-2 <code>SVector</code> of <code>Float32</code> elements.</li></ul><p>A couple of helpful type aliases are also provided:</p><ul><li><code>SA_F64[1, 2]</code> creates a lenght-2 <code>SVector</code> of <code>Float64</code> elements</li><li><code>SA_F32[1, 2]</code> creates a lenght-2 <code>SVector</code> of <code>Float32</code> elements</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/103e9d4dabfdb64ccb378c8539d15136dde964de/src/initializers.jl#L1-L20">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.SArray" href="#StaticArrays.SArray"><code>StaticArrays.SArray</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SArray{S, T, L}(x::NTuple{L, T})
SArray{S, T, L}(x1, x2, x3, ...)</code></pre><p>Construct a statically-sized array <code>SArray</code>. Since this type is immutable, the data must be provided upon construction and cannot be mutated later. The <code>S</code> parameter is a Tuple-type specifying the dimensions, or size, of the array - such as <code>Tuple{3,4,5}</code> for a 3×4×5-sized array. The <code>L</code> parameter is the <code>length</code> of the array and is always equal to <code>prod(S)</code>. Constructors may drop the <code>L</code> and <code>T</code> parameters if they are inferrable from the input (e.g. <code>L</code> is always inferrable from <code>S</code>).</p><pre><code class="language-none">SArray{S}(a::Array)</code></pre><p>Construct a statically-sized array of dimensions <code>S</code> (expressed as a <code>Tuple{...}</code>) using the data from <code>a</code>. The <code>S</code> parameter is mandatory since the size of <code>a</code> is unknown to the compiler (the element type may optionally also be specified).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/103e9d4dabfdb64ccb378c8539d15136dde964de/src/SArray.jl#L1-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.SHermitianCompact" href="#StaticArrays.SHermitianCompact"><code>StaticArrays.SHermitianCompact</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SHermitianCompact{N, T, L} &lt;: StaticMatrix{N, N, T}</code></pre><p>A <a href="#StaticArrays.StaticArray"><code>StaticArray</code></a> subtype that represents a Hermitian matrix. Unlike <code>LinearAlgebra.Hermitian</code>, <code>SHermitianCompact</code> stores only the lower triangle of the matrix (as an <code>SVector</code>). The lower triangle is stored in column-major order. For example, for an <code>SHermitianCompact{3}</code>, the indices of the stored elements can be visualized as follows:</p><pre><code class="language-none">┌ 1 ⋅ ⋅ ┐
| 2 4 ⋅ |
└ 3 5 6 ┘</code></pre><p>Type parameters:</p><ul><li><code>N</code>: matrix dimension;</li><li><code>T</code>: element type for lower triangle;</li><li><code>L</code>: length of the <code>SVector</code> storing the lower triangular elements.</li></ul><p>Note that <code>L</code> is always the <code>N</code>th <a href="https://en.wikipedia.org/wiki/Triangular_number">triangular number</a>.</p><p>An <code>SHermitianCompact</code> may be constructed either:</p><ul><li>from an <code>AbstractVector</code> containing the lower triangular elements; or</li><li>from a <code>Tuple</code> containing both upper and lower triangular elements in column major order; or</li><li>from another <code>StaticMatrix</code>.</li></ul><p>For the latter two cases, only the lower triangular elements are used; the upper triangular elements are ignored.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/103e9d4dabfdb64ccb378c8539d15136dde964de/src/SHermitianCompact.jl#L1-L31">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.SMatrix" href="#StaticArrays.SMatrix"><code>StaticArrays.SMatrix</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SMatrix{S1, S2, T, L}(x::NTuple{L, T})
SMatrix{S1, S2, T, L}(x1, x2, x3, ...)</code></pre><p>Construct a statically-sized matrix <code>SMatrix</code>. Since this type is immutable, the data must be provided upon construction and cannot be mutated later. The <code>L</code> parameter is the <code>length</code> of the array and is always equal to <code>S1 * S2</code>. Constructors may drop the <code>L</code>, <code>T</code> and even <code>S2</code> parameters if they are inferrable from the input (e.g. <code>L</code> is always inferrable from <code>S1</code> and <code>S2</code>).</p><pre><code class="language-none">SMatrix{S1, S2}(mat::Matrix)</code></pre><p>Construct a statically-sized matrix of dimensions <code>S1 × S2</code> using the data from <code>mat</code>. The parameters <code>S1</code> and <code>S2</code> are mandatory since the size of <code>mat</code> is unknown to the compiler (the element type may optionally also be specified).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/103e9d4dabfdb64ccb378c8539d15136dde964de/src/SMatrix.jl#L1-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.SOneTo" href="#StaticArrays.SOneTo"><code>StaticArrays.SOneTo</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SOneTo(n)</code></pre><p>Return a statically-sized <code>AbstractUnitRange</code> starting at <code>1</code>, functioning as the <code>axes</code> of a <code>StaticArray</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/103e9d4dabfdb64ccb378c8539d15136dde964de/src/SOneTo.jl#L1-L6">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.SVector" href="#StaticArrays.SVector"><code>StaticArrays.SVector</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SVector{S, T}(x::NTuple{S, T})
SVector{S, T}(x1, x2, x3, ...)</code></pre><p>Construct a statically-sized vector <code>SVector</code>. Since this type is immutable, the data must be provided upon construction and cannot be mutated later. Constructors may drop the <code>T</code> and <code>S</code> parameters if they are inferrable from the input (e.g. <code>SVector(1,2,3)</code> constructs an <code>SVector{3, Int}</code>).</p><pre><code class="language-none">SVector{S}(vec::Vector)</code></pre><p>Construct a statically-sized vector of length <code>S</code> using the data from <code>vec</code>. The parameter <code>S</code> is mandatory since the length of <code>vec</code> is unknown to the compiler (the element type may optionally also be specified).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/103e9d4dabfdb64ccb378c8539d15136dde964de/src/SVector.jl#L1-L15">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.Scalar" href="#StaticArrays.Scalar"><code>StaticArrays.Scalar</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Scalar{T}(x::T)</code></pre><p>Construct a statically-sized 0-dimensional array that contains a single element, <code>x</code>. This type is particularly useful for influencing broadcasting operations.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/103e9d4dabfdb64ccb378c8539d15136dde964de/src/Scalar.jl#L1-L6">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.Size" href="#StaticArrays.Size"><code>StaticArrays.Size</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Size(dims::Int...)</code></pre><p><code>Size</code> is used extensively throughout the <code>StaticArrays</code> API to describe <em>compile-time</em> knowledge of the size of an array. The dimensions are stored as a type parameter and are statically propagated by the compiler, resulting in efficient, type-inferrable code. For example, to create a static matrix of zeros, use <code>zeros(Size(3,3))</code> (rather than <code>zeros(3,3)</code>, which constructs a <code>Base.Array</code>).</p><p>Note that if dimensions are not known statically (e.g., for standard <code>Array</code>s), <a href="#StaticArrays.Dynamic"><code>Dynamic()</code></a> should be used instead of an <code>Int</code>.</p><pre><code class="language-none">Size(a::AbstractArray)
Size(::Type{T&lt;:AbstractArray})</code></pre><p>The <code>Size</code> constructor can be used to extract static dimension information from a given array. For example:</p><pre><code class="language-julia-repl">julia&gt; Size(zeros(SMatrix{3, 4}))
Size(3, 4)

julia&gt; Size(zeros(3, 4))
Size(StaticArrays.Dynamic(), StaticArrays.Dynamic())</code></pre><p>This has multiple uses, including &quot;trait&quot;-based dispatch on the size of a statically-sized array. For example:</p><pre><code class="language-julia">det(x::StaticMatrix) = _det(Size(x), x)
_det(::Size{(1,1)}, x::StaticMatrix) = x[1,1]
_det(::Size{(2,2)}, x::StaticMatrix) = x[1,1]*x[2,2] - x[1,2]*x[2,1]
# and other definitions as necessary</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/103e9d4dabfdb64ccb378c8539d15136dde964de/src/traits.jl#L22-L58">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.SizedArray" href="#StaticArrays.SizedArray"><code>StaticArrays.SizedArray</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SizedArray{Tuple{dims...}}(array)</code></pre><p>Wraps an <code>Array</code> with a static size, so to take advantage of the (faster) methods defined by the static array package. The size is checked once upon construction to determine if the number of elements (<code>length</code>) match, but the array may be reshaped.</p><p>The aliases <code>SizedVector{N}</code> and <code>SizedMatrix{N,M}</code> are provided as more convenient names for one and two dimensional <code>SizedArray</code>s. For example, to wrap a 2x3 array <code>a</code> in a <code>SizedArray</code>, use <code>SizedMatrix{2,3}(a)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/103e9d4dabfdb64ccb378c8539d15136dde964de/src/SizedArray.jl#L2-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.StaticArray" href="#StaticArrays.StaticArray"><code>StaticArrays.StaticArray</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">abstract type StaticArray{S, T, N} &lt;: AbstractArray{T, N} end
StaticScalar{T}     = StaticArray{Tuple{}, T, 0}
StaticVector{N,T}   = StaticArray{Tuple{N}, T, 1}
StaticMatrix{N,M,T} = StaticArray{Tuple{N,M}, T, 2}</code></pre><p><code>StaticArray</code>s are Julia arrays with fixed, known size.</p><p><strong>Dev docs</strong></p><p>They must define the following methods:</p><ul><li>Constructors that accept a flat tuple of data.</li><li><code>getindex()</code> with an integer (linear indexing) (preferably <code>@inline</code> with <code>@boundscheck</code>).</li><li><code>Tuple()</code>, returning the data in a flat Tuple.</li></ul><p>It may be useful to implement:</p><ul><li><code>similar_type(::Type{MyStaticArray}, ::Type{NewElType}, ::Size{NewSize})</code>, returning a type (or type constructor) that accepts a flat tuple of data.</li></ul><p>For mutable containers you may also need to define the following:</p><ul><li><code>setindex!</code> for a single element (linear indexing).</li><li><code>similar(::Type{MyStaticArray}, ::Type{NewElType}, ::Size{NewSize})</code>.</li><li>In some cases, a zero-parameter constructor, <code>MyStaticArray{...}()</code> for unintialized data is assumed to exist.</li></ul><p>(see also <code>SVector</code>, <code>SMatrix</code>, <code>SArray</code>, <code>MVector</code>, <code>MMatrix</code>, <code>MArray</code>, <code>SizedArray</code>, <code>FieldVector</code>, <code>FieldMatrix</code> and <code>FieldArray</code>)</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/103e9d4dabfdb64ccb378c8539d15136dde964de/src/StaticArrays.jl#L44-L72">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.setindex-Tuple{StaticArray,Any,Int64}" href="#Base.setindex-Tuple{StaticArray,Any,Int64}"><code>Base.setindex</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">setindex(vec::StaticArray, x, index::Int)</code></pre><p>Return a new array with the item at <code>index</code> replaced by <code>x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; setindex(@SVector[1,2,3], 4, 2)
3-element SArray{Tuple{3},Int64,1,3} with indices SOneTo(3):
 1
 4
 3

julia&gt; setindex(@SMatrix[2 4; 6 8], 1, 2)
2×2 SArray{Tuple{2,2},Int64,2,4} with indices SOneTo(2)×SOneTo(2):
 2  4
 1  8</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/103e9d4dabfdb64ccb378c8539d15136dde964de/src/deque.jl#L166-L184">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.deleteat-Tuple{StaticArray{Tuple{N},T,1} where T where N,Any}" href="#StaticArrays.deleteat-Tuple{StaticArray{Tuple{N},T,1} where T where N,Any}"><code>StaticArrays.deleteat</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">deleteat(vec::StaticVector, index::Integer)</code></pre><p>Return a new vector with the item at the given <code>index</code> removed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; deleteat(@SVector[6, 5, 4, 3, 2, 1], 2)
5-element SArray{Tuple{5},Int64,1,5} with indices SOneTo(5):
 6
 4
 3
 2
 1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/103e9d4dabfdb64ccb378c8539d15136dde964de/src/deque.jl#L130-L145">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.insert-Tuple{StaticArray{Tuple{N},T,1} where T where N,Any,Any}" href="#StaticArrays.insert-Tuple{StaticArray{Tuple{N},T,1} where T where N,Any,Any}"><code>StaticArrays.insert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">insert(vec::StaticVector, index::Integer, item)</code></pre><p>Return a new vector with <code>item</code> inserted into <code>vec</code> at the given <code>index</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; insert(@SVector[6, 5, 4, 2, 1], 4, 3)
6-element SArray{Tuple{6},Int64,1,6} with indices SOneTo(6):
 6
 5
 4
 3
 2
 1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/103e9d4dabfdb64ccb378c8539d15136dde964de/src/deque.jl#L52-L68">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.pop-Tuple{StaticArray{Tuple{N},T,1} where T where N}" href="#StaticArrays.pop-Tuple{StaticArray{Tuple{N},T,1} where T where N}"><code>StaticArrays.pop</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">pop(vec::StaticVector)</code></pre><p>Return a new vector with the last item in <code>vec</code> removed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; pop(@SVector[1,2,3])
2-element SArray{Tuple{2},Int64,1,2} with indices SOneTo(2):
 1
 2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/103e9d4dabfdb64ccb378c8539d15136dde964de/src/deque.jl#L84-L96">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.popfirst-Tuple{StaticArray{Tuple{N},T,1} where T where N}" href="#StaticArrays.popfirst-Tuple{StaticArray{Tuple{N},T,1} where T where N}"><code>StaticArrays.popfirst</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">popfirst(vec::StaticVector)</code></pre><p>Return a new vector with the first item in <code>vec</code> removed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; popfirst(@SVector[1,2,3])
2-element SArray{Tuple{2},Int64,1,2} with indices SOneTo(2):
 2
 3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/103e9d4dabfdb64ccb378c8539d15136dde964de/src/deque.jl#L107-L119">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.push-Tuple{StaticArray{Tuple{N},T,1} where T where N,Any}" href="#StaticArrays.push-Tuple{StaticArray{Tuple{N},T,1} where T where N,Any}"><code>StaticArrays.push</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">push(vec::StaticVector, item)</code></pre><p>Return a new <code>StaticVector</code> with <code>item</code> inserted on the end of <code>vec</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; push(@SVector[1, 2, 3], 4)
4-element SArray{Tuple{4},Int64,1,4} with indices SOneTo(4):
 1
 2
 3
 4</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/103e9d4dabfdb64ccb378c8539d15136dde964de/src/deque.jl#L1-L15">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.pushfirst-Tuple{StaticArray{Tuple{N},T,1} where T where N,Any}" href="#StaticArrays.pushfirst-Tuple{StaticArray{Tuple{N},T,1} where T where N,Any}"><code>StaticArrays.pushfirst</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">pushfirst(vec::StaticVector, item)</code></pre><p>Return a new <code>StaticVector</code> with <code>item</code> inserted at the beginning of <code>vec</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; pushfirst(@SVector[1, 2, 3, 4], 5)
5-element SArray{Tuple{5},Int64,1,5} with indices SOneTo(5):
 5
 1
 2
 3
 4</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/103e9d4dabfdb64ccb378c8539d15136dde964de/src/deque.jl#L26-L41">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.similar_type" href="#StaticArrays.similar_type"><code>StaticArrays.similar_type</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">similar_type(static_array)
similar_type(static_array, T)
similar_type(array, ::Size)
similar_type(array, T, ::Size)</code></pre><p>Returns a constructor for a statically-sized array similar to the input array (or type) <code>static_array</code>/<code>array</code>, optionally with different element type <code>T</code> or size <code>Size</code>. If the input <code>array</code> is not a <code>StaticArray</code> then the <code>Size</code> is mandatory.</p><p>This differs from <code>similar()</code> in that the resulting array type may not be mutable (or define <code>setindex!()</code>), and therefore the returned type may need to be <em>constructed</em> with its data.</p><p>Note that the (optional) size <em>must</em> be specified as a static <code>Size</code> object (so the compiler can infer the result statically).</p><p>New types should define the signature <code>similar_type(::Type{A},::Type{T},::Size{S}) where {A&lt;:MyType,T,S}</code> if they wish to overload the default behavior.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/103e9d4dabfdb64ccb378c8539d15136dde964de/src/abstractarray.jl#L36-L55">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.Dynamic" href="#StaticArrays.Dynamic"><code>StaticArrays.Dynamic</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Dynamic()</code></pre><p>Used to signify that a dimension of an array is not known statically.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/103e9d4dabfdb64ccb378c8539d15136dde964de/src/traits.jl#L1-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.similar-Union{Tuple{SA}, Tuple{SA}} where SA&lt;:StaticArray" href="#Base.similar-Union{Tuple{SA}, Tuple{SA}} where SA&lt;:StaticArray"><code>Base.similar</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">similar(static_array)
similar(static_array, T)
similar(array, ::Size)
similar(array, T, ::Size)</code></pre><p>Constructs and returns a mutable but statically-sized array (i.e. a <code>StaticArray</code>). If the input <code>array</code> is not a <code>StaticArray</code>, then the <code>Size</code> is required to determine the output size (or else a dynamically sized array will be returned).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/103e9d4dabfdb64ccb378c8539d15136dde964de/src/abstractarray.jl#L118-L127">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.qr" href="#LinearAlgebra.qr"><code>LinearAlgebra.qr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">qr(A::StaticMatrix, pivot=Val(false))</code></pre><p>Compute the QR factorization of <code>A</code>. The factors can be obtain by iteration:</p><pre><code class="language-julia">julia&gt; A = @SMatrix rand(3,4);

julia&gt; Q, R = qr(A);

julia&gt; Q * R ≈ A
true</code></pre><p>or by using <code>getfield</code>:</p><pre><code class="language-julia">julia&gt; F = qr(A);

julia&gt; F.Q * F.R ≈ A
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/103e9d4dabfdb64ccb378c8539d15136dde964de/src/qr.jl#L14-L36">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays._construct_similar-Union{Tuple{ET}, Tuple{L}, Tuple{Any,Size,Tuple{Vararg{ET,L}}}} where ET where L" href="#StaticArrays._construct_similar-Union{Tuple{ET}, Tuple{L}, Tuple{Any,Size,Tuple{Vararg{ET,L}}}} where ET where L"><code>StaticArrays._construct_similar</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">_construct_similar(a, ::Size, elements::NTuple)</code></pre><p>Construct a static array of similar type to <code>a</code> with the given <code>elements</code>.</p><p>When <code>a</code> is an instance or a concrete type the element type <code>eltype(a)</code> is used. However, when <code>a</code> is a <code>UnionAll</code> type such as <code>SMatrix{2,2}</code>, the promoted type of <code>elements</code> is used instead.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/103e9d4dabfdb64ccb378c8539d15136dde964de/src/abstractarray.jl#L102-L110">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays._size-Tuple{Any}" href="#StaticArrays._size-Tuple{Any}"><code>StaticArrays._size</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Return either the statically known Size() or runtime size()</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/103e9d4dabfdb64ccb378c8539d15136dde964de/src/traits.jl#L176-L178">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.arithmetic_closure-Union{Tuple{Type{T}}, Tuple{T}} where T" href="#StaticArrays.arithmetic_closure-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>StaticArrays.arithmetic_closure</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">arithmetic_closure(T)</code></pre><p>Return the type which values of type <code>T</code> will promote to under a combination of the arithmetic operations <code>+, -, *</code> and <code>/</code>.</p><pre><code class="language-julia-repl">julia&gt; import StaticArrays.arithmetic_closure

julia&gt; arithmetic_closure(Bool)
Float64

julia&gt; arithmetic_closure(Int32)
Float64

julia&gt; arithmetic_closure(BigFloat)
BigFloat

julia&gt; arithmetic_closure(BigInt)
BigFloat</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/103e9d4dabfdb64ccb378c8539d15136dde964de/src/arraymath.jl#L142-L162">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.dimmatch" href="#StaticArrays.dimmatch"><code>StaticArrays.dimmatch</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">dimmatch(x::StaticDimension, y::StaticDimension)</code></pre><p>Return whether dimensions <code>x</code> and <code>y</code> match at compile time, that is:</p><ul><li>if <code>x</code> and <code>y</code> are both <code>Int</code>s, check that they are equal</li><li>if <code>x</code> or <code>y</code> are <code>Dynamic()</code>, return true</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/103e9d4dabfdb64ccb378c8539d15136dde964de/src/traits.jl#L10-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.same_size-Tuple" href="#StaticArrays.same_size-Tuple"><code>StaticArrays.same_size</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns the common Size of the inputs (or else throws a DimensionMismatch)</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/103e9d4dabfdb64ccb378c8539d15136dde964de/src/traits.jl#L187-L189">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.size_to_tuple-Union{Tuple{Type{S}}, Tuple{S}} where S&lt;:Tuple" href="#StaticArrays.size_to_tuple-Union{Tuple{Type{S}}, Tuple{S}} where S&lt;:Tuple"><code>StaticArrays.size_to_tuple</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">size_to_tuple(::Type{S}) where S&lt;:Tuple</code></pre><p>Converts a size given by <code>Tuple{N, M, ...}</code> into a tuple <code>(N, M, ...)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/103e9d4dabfdb64ccb378c8539d15136dde964de/src/util.jl#L41-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.sizematch-Union{Tuple{S2}, Tuple{S1}, Tuple{Size{S1},Size{S2}}} where S2 where S1" href="#StaticArrays.sizematch-Union{Tuple{S2}, Tuple{S1}, Tuple{Size{S1},Size{S2}}} where S2 where S1"><code>StaticArrays.sizematch</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">sizematch(::Size, ::Size)
sizematch(::Tuple, ::Tuple)</code></pre><p>Determine whether two sizes match, in the sense that they have the same number of dimensions, and their dimensions match as determined by <a href="#StaticArrays.dimmatch"><code>dimmatch</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/103e9d4dabfdb64ccb378c8539d15136dde964de/src/traits.jl#L153-L159">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.sizematch-Union{Tuple{S}, Tuple{Size{S},StaticArray}} where S" href="#StaticArrays.sizematch-Union{Tuple{S}, Tuple{Size{S},StaticArray}} where S"><code>StaticArrays.sizematch</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">sizematch(::Size, A::AbstractArray)</code></pre><p>Determine whether array <code>A</code> matches the given size. If <code>A</code> is a <code>StaticArray</code>, the check is performed at compile time, otherwise, the check is performed at runtime.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/103e9d4dabfdb64ccb378c8539d15136dde964de/src/traits.jl#L166-L172">source</a></section><footer><hr/><a class="previous" href="../../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../quickstart/"><span class="direction">Next</span><span class="title">Quick Start</span></a></footer></article></body></html>
